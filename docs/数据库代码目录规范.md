# 数据库代码目录规范

本文档描述项目中数据库相关代码的目录结构规范和设计原则。

## 推荐的目录结构

```
项目根目录/
├── db/                            # 数据库脚本（不属于应用代码）
│   ├── migrations/                # 数据库迁移脚本
│   │   ├── 001_create_users.sql
│   │   ├── 002_create_products.sql
│   │   └── 003_add_user_phone.sql
│   ├── seeds/                     # 种子数据
│   │   └── init_data.sql
│   └── schema.sql                 # 完整表结构（可选）
│
└── src/
    ├── lib/
    │   └── db/                    # 数据库基础设施代码
    │       ├── config.ts          # 数据库配置
    │       ├── connection.ts      # 连接池管理
    │       ├── crud.ts            # 通用 CRUD 基类
    │       └── index.ts           # 统一导出
    │
    ├── models/                    # 业务实体定义
    │   ├── index.ts               # 统一导出
    │   ├── user.ts                # User 实体 + userRepository
    │   ├── product.ts             # Product 实体 + productRepository
    │   └── order.ts               # Order 实体 + orderRepository
    │
    ├── services/                  # 业务逻辑层（可选）
    │   ├── user.service.ts        # 用户相关业务逻辑
    │   └── product.service.ts     # 商品相关业务逻辑
    │
    └── app/
        └── api/                   # API 路由
            └── users/
                ├── route.ts
                └── [id]/route.ts
```

## 分析说明

| 目录 | 用途 | 说明 |
|------|------|------|
| `db/` | 数据库脚本 | 存放 SQL 文件，**不属于应用代码**，用于数据库初始化和维护 |
| `db/migrations/` | 迁移脚本 | 按顺序编号的建表/改表脚本，便于版本控制和增量更新 |
| `db/seeds/` | 种子数据 | 初始化数据、测试数据，按表名命名 |
| `src/lib/db/` | 基础设施代码 | 配置、连接池、通用 CRUD，**不放业务实体** |
| `src/models/` | 业务实体定义 | 定义业务实体接口和对应的 Repository 实例 |
| `src/services/` | 业务逻辑层 | 复杂业务逻辑封装（可选，简单项目可省略） |
| `src/app/api/` | API 路由 | Next.js API 路由，调用 models 或 services |

## 关键原则

### 1. SQL 文件不放 `src/` 目录

SQL 是数据库层面的脚本，不属于应用代码。将其放在项目根目录的 `db/` 文件夹中：

- **好处**：清晰区分"应用代码"和"数据库脚本"
- **场景**：DBA 或运维人员可以直接在 `db/` 目录操作，无需关心前端代码

### 2. `lib/` 存放通用基础代码

`src/lib/db/` 只放与具体业务无关的通用工具：

- `config.ts` — 数据库配置读取
- `connection.ts` — 连接池管理
- `crud.ts` — 通用 CRUD 操作基类

**不要在这里放业务实体定义**（如 User、Product）。

### 3. `models/` 存放业务实体

每个业务实体一个文件，包含：

- 实体接口定义（TypeScript interface）
- 对应的 Repository 实例

```typescript
// src/models/user.ts
import { BaseEntity, createRepository } from '@/lib/db';

export interface User extends BaseEntity {
  email: string;
  name: string;
  status: 'active' | 'inactive';
}

export const userRepository = createRepository<User>('users');
```

### 4. 迁移脚本使用数字编号

迁移脚本命名格式：`{序号}_{描述}.sql`

- `001_create_users.sql`
- `002_create_products.sql`
- `003_add_user_phone.sql`

**好处**：
- 保证执行顺序
- 便于版本控制
- 支持增量更新

### 5. 分层架构（可选）

对于复杂项目，推荐三层架构：

```
API Route → Service → Repository
   │           │          │
   │           │          └── 数据访问层（CRUD）
   │           └── 业务逻辑层（复杂业务规则）
   └── 接口层（请求处理、参数验证）
```

简单项目可以省略 Service 层，直接在 API Route 中调用 Repository。

## 命名规范

| 类型 | 命名格式 | 示例 |
|------|----------|------|
| 迁移脚本 | `{序号}_{描述}.sql` | `001_create_users.sql` |
| 种子数据 | `{表名}.sql` | `users.sql` |
| 实体文件 | `{实体名}.ts` (小写) | `user.ts`, `product.ts` |
| Service 文件 | `{实体名}.service.ts` | `user.service.ts` |
| Repository 变量 | `{实体名}Repository` | `userRepository` |

## 使用示例

### 导入实体和仓库

```typescript
// 从统一入口导入
import { User, userRepository } from '@/models';

// 或单独导入
import { userRepository } from '@/models/user';
```

### 在 API 路由中使用

```typescript
// src/app/api/users/route.ts
import { userRepository } from '@/models';

export async function GET() {
  const users = await userRepository.findMany({ status: 'active' });
  return Response.json({ data: users });
}
```

### 在 Service 中使用

```typescript
// src/services/user.service.ts
import { userRepository, User } from '@/models';

export async function createUserWithValidation(data: Omit<User, 'id'>) {
  // 业务逻辑：检查邮箱是否已存在
  const exists = await userRepository.exists({ email: data.email });
  if (exists) {
    throw new Error('邮箱已被使用');
  }
  
  return userRepository.create(data);
}
```
